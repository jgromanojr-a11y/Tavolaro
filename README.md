<!DOCTYPE html> <html lang="pt-BR"> <head> <meta charset="utf-8" /> <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no" /> <title>Espaço-Z (versão completa)</title> <style>   html,body{height:100%;margin:0;background:#000;color:#fff;font-family:Arial,Helvetica,sans-serif;overflow:hidden;}   #game{display:block;width:100%;height:100%;}   #ui{position:absolute;left:0;right:0;bottom:0;pointer-events:none;}   #stats{pointer-events:auto; display:flex; justify-content:space-between; width:100%; max-width:720px; margin:0 auto; padding:8px;}   #controls{pointer-events:auto; display:flex; justify-content:space-between; align-items:center; width:100%; max-width:720px; margin:0 auto 12px; padding:0 8px; box-sizing:border-box;}   #joystick{width:130px;height:130px;border-radius:50%;background:rgba(255,255,255,0.12);position:relative;touch-action:none;user-select:none;}   #stick{width:60px;height:60px;border-radius:50%;background:rgba(255,255,255,0.5);position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);}   #pauseBtn,#fireBtn{width:80px;height:80px;border-radius:50%;border:none;background:rgba(60,60,60,0.7);color:white;font-weight:bold;font-size:1rem;cursor:pointer;pointer-events:auto;}   #fireBtn{background:rgba(200,30,30,0.85);}   .overlay{position:absolute;inset:0;background:rgba(0,0,0,0.85);display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;opacity:0;visibility:hidden;transition:opacity .3s;}   .overlay.show{opacity:1;visibility:visible;}   .diff-buttons{display:flex;flex-direction:column;margin-top:18px;}   .diff-buttons button, #restartBtn{font-size:1.05rem;padding:12px 28px;margin:8px;background:#333;border:2px solid #555;color:#fff;border-radius:6px;cursor:pointer;}   .diff-buttons button:active,#restartBtn:active{transform:translateY(1px);}   #lives{min-width:100px;text-align:left;}   #score{min-width:120px;text-align:center;}   #diff{min-width:200px;text-align:right;} </style> </head> <body> <canvas id="game"></canvas>  <div id="ui">   <div id="stats">     <div id="lives">Vidas: 5</div>     <div id="score">Score: 0</div>     <div id="diff">Dificuldade: Fácil</div>   </div>   <div id="controls">     <div id="joystick"><div id="stick"></div></div>     <button id="pauseBtn">⏸</button>     <button id="fireBtn">FOGO</button>   </div> </div>  <div id="startOverlay" class="overlay show">   <h1 style="font-size:3rem;margin:0;">Sobrevivencia Espacial</h1>   <p style="font-size:1.2rem;margin:8px 0 0;">Escolha a dificuldade</p>   <div class="diff-buttons">     <button class="diffBtn" data-diff="easy">Fácil</button>     <button class="diffBtn" data-diff="medium">Médio</button>     <button class="diffBtn" data-diff="hard">Difícil</button>   </div> </div>  <div id="gameOver" class="overlay">   <h1 style="font-size:3rem;margin:0;">Game Over</h1>   <p id="finalScore" style="font-size:1.2rem;margin-top:12px;">Score: 0</p>   <button id="restartBtn" style="margin-top:18px;">Tente Novamente</button> </div>  <!-- no-audio tag: we won't autoplay; music can be started after interaction --> <audio id="bgm" src="https://files.catbox.moe/46pprg.mp3" preload="auto" loop></audio>  <script> (() => {   
  // ===== Canvas HiDPI setup =====   const canvas = document.getElementById('game');   const ctx = canvas.getContext('2d', { alpha: false });   let DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));   let W = 0, H = 0;   function resize() {     DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));     W = Math.floor(window.innerWidth * DPR);     H = Math.floor(window.innerHeight * DPR);     canvas.width = W;     canvas.height = H;     canvas.style.width = (W / DPR) + 'px';     canvas.style.height = (H / DPR) + 'px';   }   window.addEventListener('resize', resize, { passive: true });   resize();    // ===== Game state & config =====   const MAX_LIVES = 5;   const state = {     running: false,     paused: false,     score: 0,     lives: MAX_LIVES,     diff: 'easy',     spawnTimer: 0,     lastShot: 0,     time: 0   };    const DIFFS = {     easy: { label: 'Fácil', spawn: 900, speed: 0.16, max: 5 },     medium: { label: 'Médio', spawn: 650, speed: 0.22, max: 7 },     hard: { label: 'Difícil', spawn: 420, speed: 0.30, max: 9 }   };    let last = performance.now();    // player   const player = { x: W/2, y: H*0.85, w: 36 * DPR, h: 44 * DPR, speed: 0.6 };    // containers   const bullets = [];   const enemies = [];   const particles = [];   const hearts = [];   const planets = [];    // UI refs   const scoreEl = document.getElementById('score');   const livesEl = document.getElementById('lives');   const diffEl = document.getElementById('diff');   const startOverlay = document.getElementById('startOverlay');   const gameOver = document.getElementById('gameOver');   const finalScore = document.getElementById('finalScore');   const pauseBtn = document.getElementById('pauseBtn');   const restartBtn = document.getElementById('restartBtn');   const bgm = document.getElementById('bgm');    // Sound unlocking (WebAudio small oscillator to unlock)   let audioCtx = null;   function unlockAudio() {     if (!audioCtx) {       audioCtx = new (window.AudioContext || window.webkitAudioContext)();       const o = audioCtx.createOscillator();       const g = audioCtx.createGain();       g.gain.value = 0.0001;       o.connect(g).connect(audioCtx.destination);       o.start();       o.stop(audioCtx.currentTime + 0.01);     }   }   function playMusic() {     if (!bgm) return;     bgm.volume = 0.22;     const p = bgm.play();     if (p && p.catch) p.catch(()=>{ /* ignore autoplay block */ });   }    // helpers   function rand(a,b){ return a + Math.random()*(b-a); }   function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }   function overlap(a,b){     return Math.abs(a.x - b.x) * 2 < (a.w + b.w) && Math.abs(a.y - b.y) * 2 < (a.h + b.h);   }    // ===== Planets (re-generated at reset) =====   const NUM_PLANETS = 2;   function regenPlanets(){     planets.length = 0;     for(let i=0;i<NUM_PLANETS;i++){       planets.push({         x: rand(30 * DPR, W - 30 * DPR),         y: rand(20 * DPR, H * 0.55),         r: rand(20 * DPR, 60 * DPR),         color: `rgba(${Math.floor(rand(50,150))}, ${Math.floor(rand(50,150))}, ${Math.floor(rand(100,200))}, 0.7)`       });     }   }    // ===== UI - difficulty buttons =====   document.querySelectorAll('.diffBtn').forEach(btn => {     const handler = (e) => { e.preventDefault(); unlockAudio(); playMusic(); startGame(btn.dataset.diff); };     btn.addEventListener('click', handler);     btn.addEventListener('touchstart', handler, { passive: false });   });    restartBtn.addEventListener('click', () => {     startOverlay.classList.add('show');     gameOver.classList.remove('show');     state.running = false;   });    pauseBtn.addEventListener('click', () => {     if (!state.running) return;     state.paused = !state.paused;     pauseBtn.textContent = state.paused ? '▶️' : '⏸';   });    // ===== Joystick (touch and mouse) =====   const joyBase = document.getElementById('joystick');   const joyStick = document.getElementById('stick');   let joy = { active:false, dx:0, dy:0, radius: 65 };    function setStickPositionDOM(left, top){     joyStick.style.left = left;     joyStick.style.top = top;   }    function moveStickFromPoint(px, py){     const r = joy.radius;     const dx = px - r;     const dy = py - r;     const dist = Math.sqrt(dx*dx + dy*dy);     if (dist > r) {       const angle = Math.atan2(dy, dx);       setStickPositionDOM( (r + r*Math.cos(angle)) + 'px', (r + r*Math.sin(angle)) + 'px' );     } else {       setStickPositionDOM(px + 'px', py + 'px');     }     joy.dx = dx / r;     joy.dy = dy / r;   }    function getJoyPosFromEvent(e){     const t = e.touches ? e.touches[0] : e;     const r = joyBase.getBoundingClientRect();     return { x: (t.clientX - r.left), y: (t.clientY - r.top) };   }    function joyStart(e){     unlockAudio();     playMusic();     joy.active = true;     const p = getJoyPosFromEvent(e);     moveStickFromPoint(p.x, p.y);     e.preventDefault();   }   function joyMove(e){     if(!joy.active) return;     const p = getJoyPosFromEvent(e);     moveStickFromPoint(p.x, p.y);     e.preventDefault();   }   function joyEnd(){     joy.active = false;     joy.dx = joy.dy = 0;     setStickPositionDOM('50%','50%');   }    joyBase.addEventListener('touchstart', joyStart, { passive:false });   joyBase.addEventListener('touchmove', joyMove, { passive:false });   joyBase.addEventListener('touchend', joyEnd, { passive:false });   joyBase.addEventListener('mousedown', (e)=>{ joyStart(e); window.addEventListener('mousemove', joyMove); window.addEventListener('mouseup', onMouseUp); });   function onMouseUp(e){ joyEnd(); window.removeEventListener('mousemove', joyMove); window.removeEventListener('mouseup', onMouseUp); }    // ===== Fire button: normal and super shot (hold) =====   const fireBtn = document.getElementById('fireBtn');   let firing = false;   let fireHoldStart = 0;    function fireStart(){     unlockAudio();     playMusic();     firing = true;     fireHoldStart = performance.now();   }   function fireEnd(){     firing = false;     fireHoldStart = 0;   }    fireBtn.addEventListener('touchstart', (e)=>{ fireStart(); }, { passive:true });   fireBtn.addEventListener('touchend', (e)=>{ fireEnd(); }, { passive:true });   fireBtn.addEventListener('mousedown', ()=> fireStart() );   fireBtn.addEventListener('mouseup', ()=> fireEnd() );    // ===== Spawning enemies & hearts =====   function spawnEnemy(){     const types = [       { name:'small', w:24, h:22, color:'#ff6363', score:10, speedMul:1.0 },       { name:'medium', w:32, h:28, color:'#ffb84a', score:20, speedMul:0.9 },       { name:'large', w:42, h:36, color:'#7cff84', score:50, speedMul:0.75 }     ];     const t = types[Math.floor(Math.random()*types.length)];     const e = {       type: t,       x: rand(30 * DPR, W - 30 * DPR),       y: -40 * DPR,       w: t.w * DPR,       h: t.h * DPR,       vy: (DIFFS[state.diff].speed * t.speedMul) * DPR,       vx: (Math.random() < 0.5 ? -1 : 1) * rand(0.05, 0.12) * DPR,       color: t.color,       score: t.score     };     enemies.push(e);   }    function spawnHeart(){     hearts.push({       x: rand(30 * DPR, W - 30 * DPR),       y: -30 * DPR,       w: 28 * DPR,       h: 28 * DPR,       vy: 0.12 * DPR     });   }    // ===== Explosions / particles =====   function spawnExplosion(x,y,n=16,color='#ffa800'){     for(let i=0;i<n;i++){       particles.push({         x, y,         r: rand(1,3) * DPR,         life: rand(220,480),         vx: Math.cos(i / n * Math.PI * 2) * rand(0.08,0.35) * DPR,         vy: Math.sin(i / n * Math.PI * 2) * rand(0.08,0.35) * DPR,         color       });     }   }    // ===== Reset / Start / Game Over =====   function reset(diff){     state.running = true;     state.paused = false;     state.score = 0;     state.lives = MAX_LIVES;     state.diff = diff;     state.spawnTimer = 0;     state.lastShot = 0;     state.time = 0;     bullets.length = 0;     enemies.length = 0;     particles.length = 0;     hearts.length = 0;     regenPlanets();     player.x = W / 2;     player.y = H * 0.85;     diffEl.textContent = 'Dificuldade: ' + DIFFS[diff].label;     livesEl.textContent = 'Vidas: ' + state.lives;     scoreEl.textContent = 'Score: ' + state.score;     pauseBtn.textContent = '⏸';   }    function startGame(diff){     startOverlay.classList.remove('show');     gameOver.classList.remove('show');     reset(diff);     last = performance.now();   }    function gameOverNow(){     state.running = false;     finalScore.textContent = 'Score: ' + state.score;     gameOver.classList.add('show');   }    // ===== Update =====   function update(dt){     // player movement by joystick (joy.dx, joy.dy are -1..1 roughly)     const dx = joy.dx || 0;     const dy = joy.dy || 0;     const speed = player.speed * dt * DPR * 0.85;     player.x += dx * speed * 3.2;     player.y += dy * speed * 3.2;     player.x = clamp(player.x, player.w / 2 + 10 * DPR, W - player.w / 2 - 10 * DPR);     player.y = clamp(player.y, player.h / 2 + 10 * DPR, H - player.h / 2 - 10 * DPR);      // firing logic: normal or super when holding     if (firing && (state.time - state.lastShot) > 160){       const held = performance.now() - fireHoldStart;       if (held >= 1200) {         // super shot: wider, faster, 'super' flag (passes through)         bullets.push({ x: player.x, y: player.y - player.h / 2, w: 20 * DPR, h: 36 * DPR, vy: -1.4 * DPR, super: true });       } else {         bullets.push({ x: player.x, y: player.y - player.h / 2, w: 6 * DPR, h: 14 * DPR, vy: -0.9 * DPR });       }       state.lastShot = state.time;     }      // update bullets     for (let i = bullets.length - 1; i >= 0; i--){       const b = bullets[i];       b.y += b.vy * dt;       if (b.y + b.h < -40) bullets.splice(i,1);     }      // spawn enemies periodically     state.spawnTimer += dt;     const spawnEvery = DIFFS[state.diff].spawn;     if (state.spawnTimer > spawnEvery) {       state.spawnTimer = 0;       spawnEnemy();     }      // update enemies: movement, collisions with bullets and player     for (let i = enemies.length - 1; i >= 0; i--){       const e = enemies[i];       e.y += e.vy * dt;       e.x += e.vx * dt;       if (e.x < e.w/2 || e.x > W - e.w/2) e.vx *= -1;        // bullets collision       let killed = false;       for (let j = bullets.length - 1; j >= 0; j--){         const b = bullets[j];         if ( overlap({ x: b.x, y: b.y, w: b.w, h: b.h }, e) ){           state.score += e.score || 10;           scoreEl.textContent = 'Score: ' + state.score;           spawnExplosion(e.x, e.y, 18, e.color);           // if bullet is not super, remove it. super bullets pass through.           if (!b.super) bullets.splice(j,1);           enemies.splice(i,1);           killed = true;           break;         }       }       if (killed) continue;        // player collision       if ( overlap(e, player) ){         enemies.splice(i,1);         spawnExplosion(player.x, player.y, 24, '#66ffff');         state.lives -= 1;         livesEl.textContent = 'Vidas: ' + state.lives;         if (state.lives <= 0) { gameOverNow(); return; }       }        if (e.y - e.h/2 > H + 60) enemies.splice(i,1);     }      // update hearts (collectable)     // spawn hearts randomly but not too often (roughly once each ~12s in expectation)     if (Math.random() < 0.0012) spawnHeart();     for (let i = hearts.length - 1; i >= 0; i--){       const h = hearts[i];       h.y += h.vy * dt;       if (h.y > H + 40) { hearts.splice(i,1); continue; }        // collision with player: heal +1 (cap)       if ( overlap({x:h.x,y:h.y,w:h.w,h:h.h}, player) ){         hearts.splice(i,1);         if (state.lives < MAX_LIVES) {           state.lives++;           livesEl.textContent = 'Vidas: ' + state.lives;         }       }     }      // particles     for (let i = particles.length - 1; i >= 0; i--){       const p = particles[i];       p.x += p.vx * dt;       p.y += p.vy * dt;       p.life -= dt;       p.vy += 0.00015 * dt;       if (p.life <= 0) particles.splice(i,1);     }      state.time += dt;   }    // ===== Drawing =====   function roundedRect(x,y,w,h,r){     ctx.beginPath();     ctx.moveTo(x+r,y);     ctx.arcTo(x+w,y,x+w,y+h,r);     ctx.arcTo(x+w,y+h,x,y+h,r);     ctx.arcTo(x,y+h,x,y,r);     ctx.arcTo(x,y,x+w,y,r);     ctx.closePath();   }    function drawShip(x,y,w,h){     ctx.save(); ctx.translate(x,y);     // main body     ctx.fillStyle = "#3a2c6d";     ctx.beginPath();     ctx.moveTo(0,-h/2);     ctx.bezierCurveTo(w/3,-h/3,w/3,h/3,0,h/2);     ctx.bezierCurveTo(-w/3,h/3,-w/3,-h/3,0,-h/2);     ctx.closePath(); ctx.fill();     ctx.strokeStyle="#222"; ctx.lineWidth=1*DPR; ctx.stroke();      // nose     ctx.fillStyle="#ff4500"; ctx.beginPath();     ctx.moveTo(0,h/2); ctx.lineTo(-w/6,h/2.5); ctx.lineTo(0,h/1.7); ctx.lineTo(w/6,h/2.5); ctx.closePath(); ctx.fill();      // cockpit     ctx.fillStyle="#f8a9c0"; ctx.beginPath();     ctx.ellipse(0,-h/3,w/4,h/6,0,0,Math.PI*2); ctx.fill();      // wings (stroked)     ctx.strokeStyle="#4a3d8f"; ctx.lineWidth=6*DPR;     ctx.beginPath(); ctx.moveTo(-w/2.5,-h/4); ctx.quadraticCurveTo(-w/1.5,0,-w/2.5,h/3); ctx.stroke();     ctx.beginPath(); ctx.moveTo(w/2.5,-h/4); ctx.quadraticCurveTo(w/1.5,0,w/2.5,h/3); ctx.stroke();      // thrusters     ctx.fillStyle="#d98e2d";     ctx.beginPath(); ctx.arc(-w/2.5,h/3,w/6,0,Math.PI*2); ctx.fill();     ctx.beginPath(); ctx.arc(w/2.5,h/3,w/6,0,Math.PI*2); ctx.fill();     ctx.restore();   }    function drawAlien(x,y,w,h,color){     ctx.save(); ctx.translate(x,y);     ctx.fillStyle = color;     ctx.beginPath(); ctx.ellipse(0,0,w/2,h/3,0,0,Math.PI*2); ctx.fill();      // eyes     ctx.fillStyle='#fff';     ctx.beginPath(); ctx.arc(-w/4,-h/6,w/8,0,Math.PI*2); ctx.fill();     ctx.beginPath(); ctx.arc(w/4,-h/6,w/8,0,Math.PI*2); ctx.fill();      // pupils     ctx.fillStyle='#000';     ctx.beginPath(); ctx.arc(-w/4,-h/6,w/16,0,Math.PI*2); ctx.fill();     ctx.beginPath(); ctx.arc(w/4,-h/6,w/16,0,Math.PI*2); ctx.fill();      ctx.restore();   }    function drawHeartSprite(x,y,w,h){     // simple stylized heart with bezier; centered at x,y     ctx.save();     ctx.translate(x,y);     ctx.scale(1,1);     ctx.fillStyle = '#ff4d7a';     ctx.beginPath();     ctx.moveTo(0, h*0.25);     ctx.bezierCurveTo(-w*0.5, h* -0.15, -w*0.5, -h*0.8, 0, -h*0.4);     ctx.bezierCurveTo(w*0.5, -h*0.8, w*0.5, h* -0.15, 0, h*0.25);     ctx.closePath(); ctx.fill();     ctx.restore();   }    function drawHeartsHUD(){     const size = 18 * DPR;     const pad = 8 * DPR;     for (let i = 0; i < state.lives; i++){       const x = pad + i * (size + 6 * DPR);       const y = pad;       // small heart       ctx.save();       ctx.translate(x + size/2, y + size/2);       ctx.fillStyle = '#ff4d4d';       ctx.beginPath();       ctx.moveTo(0, size*0.12);       ctx.bezierCurveTo(-size*0.4, -size*0.1, -size*0.4, -size*0.6, 0, -size*0.35);       ctx.bezierCurveTo(size*0.4, -size*0.6, size*0.4, -size*0.1, 0, size*0.12);       ctx.closePath(); ctx.fill();       ctx.restore();     }   }    function draw(){     // clear     ctx.fillStyle = '#000';     ctx.fillRect(0,0,W,H);      // planets     planets.forEach(p=>{       ctx.fillStyle = p.color;       ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();     });      // stars (subtle)     for (let i=0;i<60;i++){       const sx = (i*97 + (state.time * 0.05)) % W;       const sy = (i*131 + (state.time * 0.12)) % H;       ctx.globalAlpha = 0.28 + ((i % 3) / 10);       ctx.fillStyle = '#8ff';       ctx.fillRect(sx, sy, 2 * DPR, 2 * DPR);     }     ctx.globalAlpha = 1;      // player     drawShip(player.x, player.y, player.w, player.h);      // bullets     bullets.forEach(b=>{       ctx.fillStyle = b.super ? '#ffdd55' : '#9ff';       roundedRect(b.x - b.w/2, b.y - b.h/2, b.w, b.h, 2*DPR);       ctx.fill();     });      // enemies     enemies.forEach(e => drawAlien(e.x, e.y, e.w, e.h, e.color));      // hearts (in world)     hearts.forEach(h => drawHeartSprite(h.x, h.y, h.w, h.h));      // particles     particles.forEach(p=>{       ctx.globalAlpha = Math.max(0, p.life / 480);       ctx.fillStyle = p.color;       ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();       ctx.globalAlpha = 1;     });      // HUD hearts     drawHeartsHUD();   }    // ===== Main loop =====   function loop(now){     const dt = now - last;     last = now;     if (state.running && !state.paused) update(dt);     draw();     requestAnimationFrame(loop);   }   requestAnimationFrame(loop);    // ensure initial UI text   livesEl.textContent = 'Vidas: ' + state.lives;   scoreEl.textContent = 'Score: ' + state.score;   diffEl.textContent = 'Dificuldade: ' + DIFFS[state.diff].label;    // ===== Start adjustments after DOM ready/resize =====   // regenerate planets once we know W/H (on first resize)   setTimeout(()=>{ regenPlanets(); player.x = W/2; player.y = H*0.85; }, 50);  })(); </script> </body> </html
